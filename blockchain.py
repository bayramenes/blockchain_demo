from datetime import datetime
import json
from urllib.parse import urlparse
import requests


# for cryptography
import hashlib
from ellipticcurve.ecdsa import Ecdsa
from ellipticcurve.privateKey import PrivateKey
from ellipticcurve.publicKey import PublicKey
from ellipticcurve.signature import Signature


# a class to manipulate and do different operations with the chain


class BlockChain:
    def __init__(self):
        # the utxo list which is basically transactions that someone received but didn't use for spending yet
        self.balance = {}
        # the chain copy that will be stored as long as the node is alive
        self.chain = []

        # the list of verified transactions that are waiting to be written to the blockchain by mining
        self.mempool = []

        # the file that contains the nodes

        self.file = open("nodes.json", "r+")

        # read the nodes from the file above
        self.nodeData = json.load(self.file)
        self.nodes = self.nodeData["nodes"]
        #  miner private key
        self.nodePrivateKey = self.nodeData["self"]["private"]

        # miner public key
        self.nodePublicKey = self.nodeData["self"]["public"]
        # miner wallet address

        if self.nodePublicKey != "":

            self.nodeAddress = (
                hashlib.sha256(self.nodePublicKey.encode()).hexdigest().upper()
            )
        else:
            self.nodeAddress = ""

    # check the balance of a given address in the blockchain

    def checkBalance(self, address):
        if address in self.balance.keys():

            return self.balance[address]
        else:
            return 0

    # verify the integrity of the transaction by first checking whether that signature is in fact generated by
    # the private key of the public key and the data given by the user

    def verifyTx(self, publicKey, signature, message, sender, amount):
        public = PublicKey.fromString(publicKey)
        sign = Signature._fromString(signature)

        if Ecdsa.verify(message=message, signature=sign, publicKey=public):
            if hashlib.sha256(publicKey.encode()).hexdigest().upper() == sender.upper():
                if self.checkBalance(sender) >= int(amount):
                    return {"message": "everything is fine", "isValid": True}
                else:
                    return {"message": "no balance", "isValid": False}
            else:
                return {"message": "address no applicable", "isValid": False}
        else:
            return {
                "message": "signature or message is wrong couldnt approve identity",
                "isValid": False,
            }

    # generate a new ecdsa signature given the private key and the message

    def genSig(self, privateKey, message):

        priv = PrivateKey.fromString(privateKey)

        signature = Ecdsa.sign(message=message, privateKey=priv)._toString()
        return signature

    # generate a new private-public key pair and hash the public key in order to get the address for this pair that can be used to send transactions

    def genKeyPair(self):
        privateKey = PrivateKey()
        publicKey = privateKey.publicKey()
        return {
            "private key": privateKey.toString(),
            "public key": publicKey.toString(),
            "address": hashlib.sha256(publicKey.toString().encode()).hexdigest(),
        }

    # get the nodes of the network registered in this node

    def getNetwork(self):
        return self.nodes

    # get the chain as a json object with the length of chain
    def getChain(self):
        return {"chain": self.chain, "balance": self.balance, "length": len(self.chain)}

    # mine the block with the pending transactions in the mempool
    def mineBlock(self):
        prevhash = ""
        if len(self.chain) == 0:
            prevhash = "0" * 64
        else:
            prevhash = self.chain[-1]["hash"]
        self.addTx(
            {"sender": "", "receiver": self.nodeAddress, "amount": 1000}, index=0
        )
        block = {
            "index": len(self.chain) + 1,
            "timestamp": datetime.timestamp(datetime.now()),
            "prevhash": prevhash,
            "transactions": self.mempool,
        }
        newBlock = self.proofOfWork(blockToProve=block)

        self.chain.append(newBlock)

        # delete all previous transactions
        self.mempool = []

        # broadcast the new block to the blockchain network

        self.broadCastNewBlock()

        # add a transaction to the miner from the network whenever the miners mines a block gets it

        return newBlock["hash"]

        #  add transactions to the blockchain given the details and generate the transaction
        # hash and add it to the mempool in the given index

    def addTx(self, data, index):
        data["txHash"] = hashlib.sha256(json.dumps(data).encode()).hexdigest().upper()
        self.mempool.insert(index, data)
        if data["receiver"] in self.balance.keys():

            self.balance[data["receiver"]] += data["amount"]
        else:
            self.balance[data["receiver"]] = data["amount"]
        if data["sender"] != "":
            self.balance[data["sender"]] -= data["amount"]
            if self.balance[data["sender"]] == 0:
                self.balance.pop(data["sender"], None)
        return {"index": len(self.chain) + 1, "txHash": data["txHash"]}

    # check the validity of any blockchain
    # usually this will be used to test the integrity of the blockchain that is going to be sent by other nodes to test whether the chain
    # is corrupt or not
    def check_validity(self, chain):

        if len(chain) < 1:
            return True
        if len(chain) == 1:
            if chain[0]["hash"][:4] == "0000":
                return True
            else:
                return False
        for i in range(1, len(chain)):

            curBlock = chain[i]

            prevBlock = chain[i - 1]

            if curBlock["hash"][:4] != "0000" or prevBlock["hash"][:4] != "0000":
                return False
            if curBlock["prevhash"] != prevBlock["hash"]:
                return False

        return True

        # given the address of a node add it to the current list in the memory
        # and to the json list in nodes.json file

    def addNode(self, address):
        try:

            parsed = urlparse(address)
            self.nodes.append(parsed.netloc)
            self.file.seek(0)
            json.dump(self.nodeData, self.file, indent=4)
            self.file.truncate()
            return True

        except:
            return False

    # given a new chain replace it with the old one

    def replaceChain(self, newChain):
        self.chain = newChain

    #  when a new block is mined iterate over every node on the network sending them your own version of the chain
    # that they can compare it to theirs and replace their blockchain version if needed

    def broadCastNewBlock(self):
        network = self.nodes
        for node in network:
            try:

                response = requests.post(
                    f"http://{node}/replace_chain", json=self.chain
                )

            except:
                pass

    # take the block as an argument and then creates a nonce for it and hashes it and increments the nonce until
    # the hash satisfies the criteria given which is that it should start with 4 zeros

    def proofOfWork(self, blockToProve):
        blockToProve["nonce"] = 0

        isProved = False
        while isProved is False:

            blockEncoded = json.dumps(blockToProve).encode()

            hash = hashlib.sha256(blockEncoded).hexdigest().upper()
            if hash[:4] == "0000":
                isProved = True
            else:
                blockToProve["nonce"] += 1

        blockToProve["hash"] = hash
        return blockToProve
